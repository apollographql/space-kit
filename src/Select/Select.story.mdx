import userEvent from "@testing-library/user-event";
import { findByRole } from "@testing-library/dom";
import { Meta, Story, ArgsTable, Canvas } from "@storybook/addon-docs/blocks";
import { PerformUserInteraction } from "../shared/PerformUserInteraction";
import { Select as SpaceKitSelect } from "../Select";
import { ListItem } from "../ListItem";
import { List } from "../List";
import { base } from "../../typography";

<Meta title="Form/Select" component={SpaceKitSelect} />

export const Select = (props) => {
  return (
    <PerformUserInteraction
      callback={async () => {
        if (document.querySelector(".sbdocs")) {
          // Do not perform interaction automatically if in Docs mode
          return;
        }
        userEvent.click(await findByRole(document.body, "button"));
      }}
    >
      <SpaceKitSelect {...props} />
    </PerformUserInteraction>
  );
};

export const StatefulCheckedListItemSelect = () => {
  const [selectedValue, setSelectedValue] = React.useState("Member");
  return (
    <Select
      checkMarks
      listAs={<List style={{ width: 300 }} />}
      listFeel="edge-to-edge"
      renderTriggerNode={(selectedItem) => {
        return <>Role: {selectedItem?.value}</>;
      }}
      value={selectedValue}
      onChange={(event) => setSelectedValue(event.target.value)}
      style={{ maxWidth: 300 }}
      title="Organization role"
    >
      {[
        {
          value: "Owner",
          description:
            "Has full administrative access to the entire organization.",
        },
        {
          value: "Member",
          description:
            "Can see every member and non-secret team in the organization, and can create new repositories.",
        },
      ].map(({ value, description }) => (
        <ListItem
          key={value}
          value={value}
          style={{ alignItems: "baseline", height: "auto" }}
        >
          <div style={{ whiteSpace: "normal", overflow: "auto" }}>
            <div style={{ ...base.base, fontWeight: "semibold" }}>{value}</div>
            <div style={{ opacity: 0.75 }}>{description}</div>
          </div>
        </ListItem>
      ))}
    </Select>
  );
};

export function SelectWithLabel({ label, ...props }) {
  const [labelProps, setLabelProps] = React.useState();
  // Wait for the label callback to be called and then click the button
  const labelPropsCallback = React.useCallback(async (incomingLabelProps) => {
    setLabelProps(incomingLabelProps);
    if (!document.querySelector(".sbdocs")) {
      // Only `click` if this is not storybook docs mode
      userEvent.click(await findByRole(document.body, "button"));
    }
  }, []);
  return (
    <React.Fragment>
      {React.cloneElement(label, labelProps)}
      <SpaceKitSelect {...props} labelPropsCallbackRef={labelPropsCallback} />
    </React.Fragment>
  );
}

# Select

**Select** is emulates a native `select` element, but rendered with Space Kit appearances.

## Rendering Options

You have two options for rendering `Select` component options.

### `option` and `optgroup`

You can use the same `<option>` and `<optgroup>` elements you would use for a native `select` element. Any nested components will not work.

<Canvas>
  <Story name="basic options">
    <Select
      initialValue=""
      renderTriggerNode={(selectedItem) => (
        <>{selectedItem?.children ?? "select an item"}</>
      )}
    >
      <option value="value a">a</option>
      <option value="value b">b</option>
    </Select>
  </Story>
  <Story name="basic optgroup">
    <Select
      renderTriggerNode={(selectedItem) => (
        <>{selectedItem?.children ?? "select an item"}</>
      )}
    >
      <optgroup label="Group of options">
        <option value="value a">a</option>
        <option value="value b">b</option>
      </optgroup>
      <optgroup label="Second of options">
        <option value="value c">c</option>
        <option value="value d">d</option>
      </optgroup>
    </Select>
  </Story>
  <Story name="disabled">
    <Select
      disabled
      renderTriggerNode={(selectedItem) => (
        <>{selectedItem?.children ?? "select an item"}</>
      )}
    >
      <option value="value a">a</option>
      <option value="value b">b</option>
    </Select>
  </Story>
</Canvas>

### `ListItem`

You can also use `ListItem` components at the root level or nested under `optgroup` elements. Again, you must render your `ListItem`s as `children` of `Select` or under the `optgroup` elements; you cannot create another component to compose from `ListItem`.

<Canvas>
  <Story name="ListItem with string children">
    <Select
      initialValue=""
      renderTriggerNode={(selectedItem) => (
        <>{selectedItem?.children ?? "select an item"}</>
      )}
    >
      <ListItem>a</ListItem>
      <ListItem>b</ListItem>
    </Select>
  </Story>
</Canvas>

You can use this behavior to add a description field and completely customize how to render each item.

<Canvas>
  <Story name="ListItem with complex children">
    <StatefulCheckedListItemSelect />
  </Story>
</Canvas>

## Labels

We're using [downshift](https://www.downshift-js.com/), specifically [`useSelect`](https://www.downshift-js.com/use-select) under the hood. `useSelect` automatically adds props to the trigger, to the list, and to the label. Space Kit's `Select` component does not render it's own `<label>` element and instead provides a `RefCallback` prop called `labelPropsCallbackRef` to provide access these props to the consumer.

Here's an example:

```tsx
import * as React from "react";
import { Select } from "@apollo/space-kit";

export const YourFunction: React.FC = () => {
  const [labelProps, setLabelProps] = React.useState();
  return (
    <React.Fragment>
      <label {...labelProps}>your label</label>
      <Select labelPropsCallbackRef={setLabelProps}>...</Select>
    </React.Fragment>
  );
};
```

If you inspect the `label` shown in the following story; you'll see that `id` and `for` props are automatically added to the `label` to tie the `label` and `Select` together.

<Canvas>
  <Story name="basic options with label">
    <SelectWithLabel
      label={<label>label</label>}
      initialValue=""
      renderTriggerNode={(selectedItem) => (
        <>{selectedItem?.children ?? "select an item"}</>
      )}
    >
      <option value="value a">a</option>
      <option value="value b">b</option>
    </SelectWithLabel>
  </Story>
</Canvas>

## Control

`Select` is intended to be a bare replacement for a `<select>` element. It can be either controlled or uncontrolled, see the [React: Uncontrolled Components](https://reactjs.org/docs/uncontrolled-components.html) docs for a more in-depth explanation.

For controlled components, you must pass a `value` prop and have the option to pass an `onChange` prop. If you don't use an `onChange` prop, as expected, the `value` can not be changed.

If you elect to use an uncontrolled component, do not pass `value` or `onChange` props. You can pass a `initialValue` for the initial to be set and then the component will control the state on it's own.

## Options

### Feel

Selects can be displayed using any of the `feel` values from `Button`.

<Canvas>
  <Story name="feel raised">
    <Select
      feel="raised"
      initialValue=""
      renderTriggerNode={(selectedItem) => (
        <>{selectedItem?.children ?? "select an item"}</>
      )}
    >
      <option>a</option>
      <optgroup label="header 1">
        <option>b</option>
      </optgroup>
    </Select>
  </Story>
  <Story name="feel flat">
    <Select
      feel="flat"
      initialValue=""
      renderTriggerNode={(selectedItem) => (
        <>{selectedItem?.children ?? "select an item"}</>
      )}
    >
      <option>a</option>
      <optgroup label="header 1">
        <option>b</option>
      </optgroup>
    </Select>
  </Story>
</Canvas>

### `selectedItemDecoration`

We have the option to use a custom decoration to indicate an item is selected. Note that this is different from when an item is highlighted from a hover or keyboard arrow.

#### `checkmark`

<Canvas>
  <Story name="selectedItemDecoration, checkmark">
    <Select feel="flat" initialValue="a" selectedItemDecoration="checkmark">
      <option>a</option>
      <option>b</option>
    </Select>
  </Story>
</Canvas>

### Size

By default, the component will match the width of it's content. The dropdown list will also match the size of the content. There are a few presets you can use to configure the width of the select trigger and you can have the dropdown list match the width of the trigger.

#### Automatic Size

<Canvas>
  <Story name="Automatic Size, Narrow">
    <Select initialValue="a">
      <option>a</option>
    </Select>
  </Story>
  <Story name="Automatic Size, Wide">
    <Select initialValue="this is a super long to show how wide the select will be">
      <option>this is a super long to show how wide the select will be</option>
    </Select>
  </Story>
</Canvas>

#### Sizes

Selects will grow and shrink with the content to up until a point (TBD)

<Canvas>
  <Story name="Small, Not Truncated">
    <Select size="small" initialValue="small">
      <option>small</option>
    </Select>
  </Story>
  <Story name="Small, Truncated">
    <Select size="small" initialValue="small truncated">
      <option>small truncated</option>
    </Select>
  </Story>
  <Story name="Medium, Not Truncated">
    <Select size="medium" initialValue="medium">
      <option>medium</option>
    </Select>
  </Story>
  <Story name="Medium, Truncated">
    <Select size="medium" initialValue="medium truncated truncated">
      <option>medium truncated truncated</option>
    </Select>
  </Story>
  <Story name="Large, Not Truncated">
    <Select size="large" initialValue="large">
      <option>large</option>
    </Select>
  </Story>
  <Story name="Large, Truncated">
    <Select size="large" initialValue="large truncated truncated">
      <option>large truncated truncated</option>
    </Select>
  </Story>
  <Story name="Extra Large, Not Truncated">
    <Select size="extra large" initialValue="extra large">
      <option>extra large</option>
    </Select>
  </Story>
  <Story name="Extra Large, Truncated">
    <Select size="extra large" initialValue="extra large truncated truncated">
      <option>extra large truncated truncated</option>
    </Select>
  </Story>
</Canvas>

### Match Trigger width

The menu width can be fixed to match the trigger button size with the `matchTriggerWidth` prop. This is most useful when you yourself define the size of the select element.

<Canvas>
  <Story name="Match Trigger Prop">
    <Select initialValue="small" matchTriggerWidth style={{ width: 150 }}>
      <option>small</option>
      <option>medium</option>
      <option>large</option>
    </Select>
  </Story>
</Canvas>

## Props

<ArgsTable of={SpaceKitSelect} />
